{"ast":null,"code":"import { AnswerStatus } from \"../constantValues\";\n\nconst json = require(\"./questionBank.json\"); //--------------------------------------------------------------------------------\n\n/* getAllQuestions function's purpose is to \"Filter()\" from the json object i.e.,\r\n   \"questions\"(imported from ./questionBank.json file using require() func.) in \r\n   order to \"find()\" the questions whose \"level\" is 1 in the questions object.\r\n*/\n\n\nexport function getAllQuestions(level) {\n  if (!level) return json[\"questions\"];\n  var ques = json[\"questions\"].filter(ques => ques.level.find(l => l === parseInt(level)));\n  return ques;\n} //---------------------------------------------------------------------------------\n//Function to check whether the question has been answered or not\n\nfunction isQuestionAnswered(ques) {\n  let ansCount = 0;\n  ques.choices.forEach(choice => {\n    if (choice.selected) ansCount++;\n  });\n  return ansCount;\n} //--------------------------------------------------------------------------------\n//Counter to know that the ques has been Attempted by checking the above func.\n\n\nexport function getAttemptCount(quesList) {\n  let quesAttempt = 0;\n  quesList.forEach(q => {\n    if (isQuestionAnswered(q)) quesAttempt++;\n  });\n  return quesAttempt;\n} //---------------------------------------------------------------------------\n\n/*Function for finally getting and storing the answer choices in the array yourAns,\r\n answered by the user and by matching them with the realAns array with the actual real answers*/\n\nexport function getAnsweredChoices(answeredQues) {\n  let realAns = [];\n  let yourAns = [];\n  let isAnswered = false; //by default the value \"false\"\n\n  let correctAnsCount = 0;\n  const answers = answeredQues.answer;\n  answeredQues.choices.forEach((choice, index) => {\n    if (answers.includes(index)) {\n      realAns.push(choice.value);\n      if (choice.selected) correctAnsCount++;\n    }\n\n    if (choice.selected) {\n      yourAns.push(choice.value);\n      isAnswered = true;\n    }\n  });\n  let status = AnswerStatus.INCORRECT;\n\n  if (correctAnsCount === answers.length) {\n    status = AnswerStatus.CORRRECT;\n  } else if (correctAnsCount > 0 && correctAnsCount < answers.length) {\n    status = AnswerStatus.PARTIALLY_CORRECT;\n  } else {\n    status = AnswerStatus.INCORRECT;\n  }\n\n  let score = correctAnsCount / answers.length;\n  return {\n    realAns,\n    yourAns,\n    isAnswered,\n    status,\n    score\n  };\n}","map":{"version":3,"sources":["C:/Users/vasu.gupta/UnUsed/Documents/online-test/src/utils/questionsUtil.js"],"names":["AnswerStatus","json","require","getAllQuestions","level","ques","filter","find","l","parseInt","isQuestionAnswered","ansCount","choices","forEach","choice","selected","getAttemptCount","quesList","quesAttempt","q","getAnsweredChoices","answeredQues","realAns","yourAns","isAnswered","correctAnsCount","answers","answer","index","includes","push","value","status","INCORRECT","length","CORRRECT","PARTIALLY_CORRECT","score"],"mappings":"AAAA,SAASA,YAAT,QAA6B,mBAA7B;;AAEA,MAAMC,IAAI,GAAGC,OAAO,CAAC,qBAAD,CAApB,C,CAEA;;AACA;AACA;AACA;AACA;;;AACA,OAAO,SAASC,eAAT,CAAyBC,KAAzB,EAAgC;AACrC,MAAI,CAACA,KAAL,EACA,OAAOH,IAAI,CAAC,WAAD,CAAX;AAEA,MAAII,IAAI,GAAGJ,IAAI,CAAC,WAAD,CAAJ,CAAkBK,MAAlB,CAA0BD,IAAD,IAClCA,IAAI,CAACD,KAAL,CAAWG,IAAX,CAAiBC,CAAD,IAAOA,CAAC,KAAKC,QAAQ,CAACL,KAAD,CAArC,CADS,CAAX;AAIA,SAAOC,IAAP;AACD,C,CAED;AACA;;AACA,SAASK,kBAAT,CAA4BL,IAA5B,EAAkC;AAChC,MAAIM,QAAQ,GAAG,CAAf;AAEAN,EAAAA,IAAI,CAACO,OAAL,CAAaC,OAAb,CAAsBC,MAAD,IAAY;AAC/B,QAAIA,MAAM,CAACC,QAAX,EACAJ,QAAQ;AACT,GAHD;AAKA,SAAOA,QAAP;AACD,C,CAED;AACA;;;AACA,OAAO,SAASK,eAAT,CAAyBC,QAAzB,EAAmC;AACxC,MAAIC,WAAW,GAAG,CAAlB;AACAD,EAAAA,QAAQ,CAACJ,OAAT,CACGM,CAAD,IAAO;AACP,QAAIT,kBAAkB,CAACS,CAAD,CAAtB,EACAD,WAAW;AACH,GAJV;AAMA,SAAOA,WAAP;AACD,C,CAED;;AACA;AACA;;AACA,OAAO,SAASE,kBAAT,CAA4BC,YAA5B,EAA0C;AAC/C,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,UAAU,GAAG,KAAjB,CAH+C,CAGvB;;AACxB,MAAIC,eAAe,GAAG,CAAtB;AACA,QAAMC,OAAO,GAAGL,YAAY,CAACM,MAA7B;AAEAN,EAAAA,YAAY,CAACT,OAAb,CAAqBC,OAArB,CAA6B,CAACC,MAAD,EAASc,KAAT,KAAmB;AAC9C,QAAIF,OAAO,CAACG,QAAR,CAAiBD,KAAjB,CAAJ,EAA6B;AAC3BN,MAAAA,OAAO,CAACQ,IAAR,CAAahB,MAAM,CAACiB,KAApB;AACA,UAAIjB,MAAM,CAACC,QAAX,EAAqBU,eAAe;AACrC;;AACD,QAAIX,MAAM,CAACC,QAAX,EAAqB;AACnBQ,MAAAA,OAAO,CAACO,IAAR,CAAahB,MAAM,CAACiB,KAApB;AACAP,MAAAA,UAAU,GAAG,IAAb;AACD;AACF,GATD;AAWA,MAAIQ,MAAM,GAAGhC,YAAY,CAACiC,SAA1B;;AAEA,MAAIR,eAAe,KAAKC,OAAO,CAACQ,MAAhC,EAAwC;AACtCF,IAAAA,MAAM,GAAGhC,YAAY,CAACmC,QAAtB;AACD,GAFD,MAEO,IAAIV,eAAe,GAAG,CAAlB,IAAuBA,eAAe,GAAGC,OAAO,CAACQ,MAArD,EAA6D;AAClEF,IAAAA,MAAM,GAAGhC,YAAY,CAACoC,iBAAtB;AACD,GAFM,MAEA;AACLJ,IAAAA,MAAM,GAAGhC,YAAY,CAACiC,SAAtB;AACD;;AAED,MAAII,KAAK,GAAGZ,eAAe,GAAGC,OAAO,CAACQ,MAAtC;AAEA,SAAO;AACLZ,IAAAA,OADK;AAELC,IAAAA,OAFK;AAGLC,IAAAA,UAHK;AAILQ,IAAAA,MAJK;AAKLK,IAAAA;AALK,GAAP;AAOD","sourcesContent":["import { AnswerStatus } from \"../constantValues\";\r\n\r\nconst json = require(\"./questionBank.json\");\r\n\r\n//--------------------------------------------------------------------------------\r\n/* getAllQuestions function's purpose is to \"Filter()\" from the json object i.e.,\r\n   \"questions\"(imported from ./questionBank.json file using require() func.) in \r\n   order to \"find()\" the questions whose \"level\" is 1 in the questions object.\r\n*/ \r\nexport function getAllQuestions(level) {\r\n  if (!level) \r\n  return json[\"questions\"];\r\n\r\n  var ques = json[\"questions\"].filter((ques) =>\r\n    ques.level.find((l) => l === parseInt(level))\r\n  );\r\n\r\n  return ques;\r\n}\r\n\r\n//---------------------------------------------------------------------------------\r\n//Function to check whether the question has been answered or not\r\nfunction isQuestionAnswered(ques) {\r\n  let ansCount = 0;\r\n\r\n  ques.choices.forEach((choice) => {\r\n    if (choice.selected) \r\n    ansCount++;\r\n  });\r\n\r\n  return ansCount;\r\n}\r\n\r\n//--------------------------------------------------------------------------------\r\n//Counter to know that the ques has been Attempted by checking the above func.\r\nexport function getAttemptCount(quesList) {\r\n  let quesAttempt = 0;\r\n  quesList.forEach(\r\n    (q) => {\r\n    if (isQuestionAnswered(q)) \r\n    quesAttempt++;\r\n           });\r\n\r\n  return quesAttempt;\r\n}\r\n\r\n//---------------------------------------------------------------------------\r\n/*Function for finally getting and storing the answer choices in the array yourAns,\r\n answered by the user and by matching them with the realAns array with the actual real answers*/\r\nexport function getAnsweredChoices(answeredQues) {\r\n  let realAns = [];\r\n  let yourAns = [];\r\n  let isAnswered = false; //by default the value \"false\"\r\n  let correctAnsCount = 0; \r\n  const answers = answeredQues.answer;\r\n\r\n  answeredQues.choices.forEach((choice, index) => {\r\n    if (answers.includes(index)) {\r\n      realAns.push(choice.value);\r\n      if (choice.selected) correctAnsCount++;\r\n    }\r\n    if (choice.selected) {\r\n      yourAns.push(choice.value);\r\n      isAnswered = true;\r\n    }\r\n  });\r\n\r\n  let status = AnswerStatus.INCORRECT;\r\n\r\n  if (correctAnsCount === answers.length) {\r\n    status = AnswerStatus.CORRRECT;\r\n  } else if (correctAnsCount > 0 && correctAnsCount < answers.length) {\r\n    status = AnswerStatus.PARTIALLY_CORRECT;\r\n  } else {\r\n    status = AnswerStatus.INCORRECT;\r\n  }\r\n\r\n  let score = correctAnsCount / answers.length;\r\n\r\n  return {\r\n    realAns,\r\n    yourAns,\r\n    isAnswered,\r\n    status,\r\n    score,\r\n  };\r\n}\r\n"]},"metadata":{},"sourceType":"module"}